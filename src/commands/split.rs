//! Atomic split commit logic.
//!
//! Groups staged changes into multiple logical commits, each with its own
//! commit message generated by the LLM.

use std::sync::Arc;

use colored::Colorize;
use serde::{Deserialize, Serialize};

use super::options::CommitOptions;
use crate::commands::commit::DiffStatsJson;
use crate::commands::json::{self, JsonOutput};
use crate::config::AppConfig;
use crate::error::{GcopError, Result};
use crate::git::diff::{FileDiff, split_diff_by_file};
use crate::git::{DiffStats, GitOperations};
use crate::llm::{CommitContext, LLMProvider, ScopeInfo};
use crate::ui;

/// A single commit group: files + message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CommitGroup {
    /// Files belonging to this commit group.
    pub files: Vec<String>,
    /// Commit message for this group.
    pub message: String,
}

/// LLM response wrapper for split commit grouping.
#[derive(Debug, Deserialize)]
struct SplitResponse {
    groups: Vec<CommitGroup>,
}

/// JSON output data for `--split --json` mode.
#[derive(Debug, Serialize)]
pub struct SplitCommitData {
    /// Generated commit groups.
    pub groups: Vec<CommitGroup>,
    /// Overall diff statistics.
    pub diff_stats: DiffStatsJson,
    /// Whether commits were actually executed.
    pub committed: bool,
}

// --- Public entry point ------------------------------------------------------

/// Main entry point for the split commit flow.
///
/// Called from `commands::commit::run_with_deps()` when `options.split` is true.
pub async fn run_split_flow(
    options: &CommitOptions<'_>,
    config: &AppConfig,
    repo: &dyn GitOperations,
    provider: &Arc<dyn LLMProvider>,
) -> Result<()> {
    let colored = options.effective_colored(config);

    let initial_feedbacks = if options.feedback.is_empty() {
        vec![]
    } else {
        vec![options.feedback.join(" ")]
    };

    // JSON mode
    if options.format.is_json() {
        return handle_split_json_mode(options, config, repo, provider, &initial_feedbacks).await;
    }

    // Check staged changes
    if !repo.has_staged_changes()? {
        ui::error(&rust_i18n::t!("commit.no_staged_changes"), colored);
        return Err(GcopError::NoStagedChanges);
    }

    // Get diff and split by file
    let diff = repo.get_staged_diff()?;
    let stats = repo.get_diff_stats(&diff)?;
    let file_diffs = split_diff_by_file(&diff);

    if file_diffs.is_empty() {
        ui::error(&rust_i18n::t!("commit.no_staged_changes"), colored);
        return Err(GcopError::NoStagedChanges);
    }

    // Workspace scope detection
    let scope_info = super::commit::compute_scope_info_pub(&stats.files_changed, config);

    ui::step(
        &rust_i18n::t!("commit.step1"),
        &rust_i18n::t!(
            "commit.analyzed",
            files = stats.files_changed.len(),
            changes = stats.insertions + stats.deletions
        ),
        colored,
    );

    // If only 1 file, no need to split - just inform and suggest normal commit
    if file_diffs.len() == 1 {
        ui::warning(&rust_i18n::t!("split.single_file"), colored);
        // Fall through to generate a single group anyway
    }

    let branch_name = repo.get_current_branch()?;
    let custom_prompt = config.commit.custom_prompt.clone();
    let mut feedbacks = initial_feedbacks;
    let max_retries = config.commit.max_retries;
    let mut attempt = 0usize;

    // Outer loop: generation
    loop {
        if attempt >= max_retries {
            ui::warning(
                &rust_i18n::t!("commit.max_retries", count = max_retries),
                colored,
            );
            return Err(GcopError::MaxRetriesExceeded(max_retries));
        }

        // Generate groups
        let mut current_groups = generate_groups(
            provider,
            &file_diffs,
            &stats,
            config,
            &feedbacks,
            options.verbose,
            &branch_name,
            &custom_prompt,
            &scope_info,
            colored,
            attempt,
        )
        .await?;

        // Display groups
        display_commit_groups(&current_groups, &file_diffs, colored);

        // dry-run mode: just show and exit
        if options.dry_run {
            return Ok(());
        }

        // auto-accept mode
        if options.yes {
            return execute_split_commits(repo, &current_groups, colored);
        }

        // Inner loop: interaction (edit stays here, regenerate breaks to outer)
        loop {
            let action = split_action_menu(colored, attempt)?;
            match action {
                SplitAction::AcceptAll => {
                    return execute_split_commits(repo, &current_groups, colored);
                }
                SplitAction::Edit => {
                    let edited = edit_groups_in_editor(&current_groups, &stats.files_changed)?;
                    if let Some(edited_groups) = edited {
                        current_groups = edited_groups;
                        display_commit_groups(&current_groups, &file_diffs, colored);
                    } else {
                        ui::warning(&rust_i18n::t!("commit.edit_cancelled"), colored);
                    }
                    // Stay in inner loop — user can edit again, accept, or regenerate
                    continue;
                }
                SplitAction::Regenerate => {
                    attempt += 1;
                    break; // break inner → outer loop regenerates
                }
                SplitAction::RegenerateWithFeedback => {
                    let new_feedback = ui::get_retry_feedback(colored)?;
                    if let Some(fb) = new_feedback {
                        feedbacks.push(fb);
                    } else {
                        ui::warning(&rust_i18n::t!("commit.feedback.empty"), colored);
                    }
                    attempt += 1;
                    break; // break inner → outer loop regenerates
                }
                SplitAction::Quit => {
                    ui::warning(&rust_i18n::t!("commit.cancelled"), colored);
                    return Ok(());
                }
            }
        }
    }
}

// --- Group generation --------------------------------------------------------

/// Generate commit groups from staged diffs using the LLM.
#[allow(clippy::too_many_arguments)]
async fn generate_groups(
    provider: &Arc<dyn LLMProvider>,
    file_diffs: &[FileDiff],
    stats: &DiffStats,
    config: &AppConfig,
    feedbacks: &[String],
    verbose: bool,
    branch_name: &Option<String>,
    custom_prompt: &Option<String>,
    scope_info: &Option<ScopeInfo>,
    colored: bool,
    attempt: usize,
) -> Result<Vec<CommitGroup>> {
    let context = CommitContext {
        files_changed: stats.files_changed.clone(),
        insertions: stats.insertions,
        deletions: stats.deletions,
        branch_name: branch_name.clone(),
        custom_prompt: custom_prompt.clone(),
        user_feedback: feedbacks.to_vec(),
        convention: config.commit.convention.clone(),
        scope_info: scope_info.clone(),
    };

    // Build split prompt (system + user)
    let (system, user) = crate::llm::prompt::build_split_commit_prompt(
        file_diffs,
        &context,
        context.custom_prompt.as_deref(),
        context.convention.as_ref(),
    );

    // Verbose: show prompt
    if verbose {
        if colored {
            eprintln!(
                "\n{}",
                rust_i18n::t!("commit.verbose.generated_prompt")
                    .cyan()
                    .bold()
            );
            eprintln!("{}", rust_i18n::t!("commit.verbose.system_prompt").cyan());
            eprintln!("{}", system);
            eprintln!("{}", rust_i18n::t!("commit.verbose.user_message").cyan());
            eprintln!("{}", user);
            eprintln!(
                "{}\n",
                rust_i18n::t!("commit.verbose.divider").cyan().bold()
            );
        } else {
            eprintln!("\n{}", rust_i18n::t!("commit.verbose.generated_prompt"));
            eprintln!("{}", rust_i18n::t!("commit.verbose.system_prompt"));
            eprintln!("{}", system);
            eprintln!("{}", rust_i18n::t!("commit.verbose.user_message"));
            eprintln!("{}", user);
            eprintln!("{}\n", rust_i18n::t!("commit.verbose.divider"));
        }
    }

    // Use non-streaming mode (we need complete JSON)
    let step_msg = if attempt == 0 {
        rust_i18n::t!("spinner.generating")
    } else {
        rust_i18n::t!("spinner.regenerating")
    };
    ui::step(&rust_i18n::t!("commit.step2"), &step_msg, colored);

    let spinner_msg = rust_i18n::t!("split.generating_groups").to_string();
    let mut spinner = ui::Spinner::new_with_cancel_hint(&spinner_msg, colored);
    spinner.start_time_display();

    // Direct query with pre-built prompts
    let raw_response = provider.send_prompt(&system, &user, Some(&spinner)).await?;

    spinner.finish_and_clear();

    // Parse the response
    parse_split_response(&raw_response, &stats.files_changed)
}

// --- Response parsing --------------------------------------------------------

/// Parse the LLM response into commit groups.
///
/// Strips markdown code fences if present, then parses JSON.
/// Validates that every staged file appears exactly once.
pub fn parse_split_response(raw: &str, expected_files: &[String]) -> Result<Vec<CommitGroup>> {
    // Strip markdown code fences
    let json_str = strip_code_fences(raw);

    // Parse JSON
    let response: SplitResponse = serde_json::from_str(json_str).map_err(|e| {
        // Truncate preview at char boundary to avoid panic on multi-byte UTF-8
        let preview: String = raw.chars().take(200).collect();
        GcopError::SplitParseFailed(format!(
            "JSON parse error: {}. Response preview: {}",
            e, preview
        ))
    })?;

    if response.groups.is_empty() {
        return Err(GcopError::SplitParseFailed(
            "LLM returned empty groups".to_string(),
        ));
    }

    // Validate: collect all files from groups
    let mut seen_files = std::collections::HashSet::new();
    for group in &response.groups {
        if group.files.is_empty() {
            return Err(GcopError::SplitParseFailed(format!(
                "Group '{}' has no files",
                group.message
            )));
        }
        if group.message.trim().is_empty() {
            return Err(GcopError::SplitParseFailed(
                "Group has empty commit message".to_string(),
            ));
        }
        for file in &group.files {
            if !seen_files.insert(file.clone()) {
                return Err(GcopError::SplitParseFailed(format!(
                    "File '{}' appears in multiple groups",
                    file
                )));
            }
        }
    }

    // Check that all expected files are covered
    let expected_set: std::collections::HashSet<_> = expected_files.iter().cloned().collect();
    let missing: Vec<_> = expected_set.difference(&seen_files).collect();
    if !missing.is_empty() {
        // Not a hard error - LLM might use slightly different paths
        // Log warning but proceed
        tracing::warn!("Some staged files not covered by LLM groups: {:?}", missing);
    }

    // Check that LLM did not return files outside the staging area.
    // Staging and committing such files would silently include unstaged working-tree
    // changes that the user never intended to commit.
    let mut extra: Vec<_> = seen_files.difference(&expected_set).cloned().collect();
    if !extra.is_empty() {
        extra.sort();
        return Err(GcopError::SplitParseFailed(format!(
            "LLM returned files not in staging area: {:?}",
            extra
        )));
    }

    Ok(response.groups)
}

/// Strip markdown code fences from a string.
fn strip_code_fences(s: &str) -> &str {
    let trimmed = s.trim();

    // Try ```json ... ``` pattern
    if let Some(rest) = trimmed.strip_prefix("```json")
        && let Some(inner) = rest.strip_suffix("```")
    {
        return inner.trim();
    }

    // Try ``` ... ``` pattern
    if let Some(rest) = trimmed.strip_prefix("```")
        && let Some(inner) = rest.strip_suffix("```")
    {
        return inner.trim();
    }

    trimmed
}

// --- Commit execution --------------------------------------------------------

/// Execute split commits sequentially with error recovery.
fn execute_split_commits(
    repo: &dyn GitOperations,
    groups: &[CommitGroup],
    colored: bool,
) -> Result<()> {
    let total = groups.len();

    ui::step(
        &rust_i18n::t!("commit.step4"),
        &rust_i18n::t!("split.committing", total = total),
        colored,
    );

    // Step 1: Unstage all files
    repo.unstage_all()?;

    // Step 2: Commit each group
    for (i, group) in groups.iter().enumerate() {
        // Stage this group's files
        repo.stage_files(&group.files)?;

        // Commit
        match repo.commit(&group.message) {
            Ok(()) => {
                if colored {
                    println!(
                        "  {} {}/{}: {}",
                        "✓".green().bold(),
                        i + 1,
                        total,
                        group.message.yellow()
                    );
                } else {
                    println!("  ✓ {}/{}: {}", i + 1, total, group.message);
                }
            }
            Err(e) => {
                // Recovery: re-stage remaining files
                let remaining_files: Vec<String> =
                    groups[i..].iter().flat_map(|g| g.files.clone()).collect();

                // Try to recover staging state
                let _ = repo.unstage_all();
                let _ = repo.stage_files(&remaining_files);

                return Err(GcopError::SplitCommitPartial {
                    completed: i,
                    total,
                    detail: e.to_string(),
                });
            }
        }
    }

    println!();
    ui::success(&rust_i18n::t!("split.success", count = total), colored);
    Ok(())
}

// --- Display -----------------------------------------------------------------

/// Display commit groups in a formatted preview.
fn display_commit_groups(groups: &[CommitGroup], file_diffs: &[FileDiff], colored: bool) {
    let total = groups.len();

    ui::step(
        &rust_i18n::t!("commit.step2"),
        &rust_i18n::t!("split.generated_groups", count = total),
        colored,
    );
    println!();

    for (i, group) in groups.iter().enumerate() {
        if colored {
            println!(
                "  {} ({} {}):",
                format!("Group {}", i + 1).cyan().bold(),
                group.files.len(),
                if group.files.len() == 1 {
                    "file"
                } else {
                    "files"
                }
            );
            println!("    {}", group.message.yellow());
        } else {
            println!(
                "  Group {} ({} {}):",
                i + 1,
                group.files.len(),
                if group.files.len() == 1 {
                    "file"
                } else {
                    "files"
                }
            );
            println!("    {}", group.message);
        }

        for file in &group.files {
            // Find diff stats for this file
            let (ins, del) = file_diffs
                .iter()
                .find(|fd| fd.filename == *file)
                .map(|fd| (fd.insertions, fd.deletions))
                .unwrap_or((0, 0));

            if colored {
                println!("    {} {} (+{} -{})", "-".dimmed(), file, ins, del);
            } else {
                println!("    - {} (+{} -{})", file, ins, del);
            }
        }
        println!();
    }
}

// --- Interactive menu --------------------------------------------------------

/// User action choices for split commit mode.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum SplitAction {
    AcceptAll,
    Edit,
    Regenerate,
    RegenerateWithFeedback,
    Quit,
}

/// Show the split commit action menu.
fn split_action_menu(colored: bool, retry_count: usize) -> Result<SplitAction> {
    use inquire::InquireError;
    use rust_i18n::t;

    let mut options = Vec::new();

    if colored {
        options.push(format!(
            "{} {}",
            "✓".green().bold(),
            t!("split.menu.accept_all").green()
        ));
        options.push(format!(
            "{} {}",
            "✎".yellow().bold(),
            t!("split.menu.edit").yellow()
        ));
        options.push(format!(
            "{} {}",
            "↻".blue().bold(),
            t!("split.menu.regenerate").blue()
        ));
        options.push(format!(
            "{} {}",
            "↻+".blue().bold(),
            t!("split.menu.regenerate_feedback").blue()
        ));
        options.push(format!(
            "{} {}",
            "✕".red().bold(),
            t!("split.menu.quit").red()
        ));
    } else {
        options.push(format!("✓ {}", t!("split.menu.accept_all")));
        options.push(format!("✎ {}", t!("split.menu.edit")));
        options.push(format!("↻ {}", t!("split.menu.regenerate")));
        options.push(format!("↻+ {}", t!("split.menu.regenerate_feedback")));
        options.push(format!("✕ {}", t!("split.menu.quit")));
    }

    let prompt = if colored {
        if retry_count == 0 {
            format!(
                "{} {}",
                t!("split.menu.choose_action").cyan().bold(),
                t!("messages.esc_to_quit").dimmed()
            )
        } else {
            format!(
                "{} {}",
                t!("commit.menu.not_satisfied").cyan().bold(),
                t!("messages.esc_to_quit").dimmed()
            )
        }
    } else if retry_count == 0 {
        format!(
            "{} {}",
            t!("split.menu.choose_action"),
            t!("messages.esc_to_quit")
        )
    } else {
        format!(
            "{} {}",
            t!("commit.menu.not_satisfied"),
            t!("messages.esc_to_quit")
        )
    };

    let selection = match inquire::Select::new(&prompt, options)
        .with_starting_cursor(0)
        .raw_prompt()
    {
        Ok(choice) => choice.index,
        Err(InquireError::OperationCanceled | InquireError::OperationInterrupted) => {
            return Ok(SplitAction::Quit);
        }
        Err(_) => return Err(GcopError::UserCancelled),
    };

    Ok(match selection {
        0 => SplitAction::AcceptAll,
        1 => SplitAction::Edit,
        2 => SplitAction::Regenerate,
        3 => SplitAction::RegenerateWithFeedback,
        _ => SplitAction::Quit,
    })
}

// --- Editor support ----------------------------------------------------------

/// TOML wrapper for editor serialization/deserialization.
#[derive(Debug, Serialize, Deserialize)]
struct EditorGroups {
    groups: Vec<CommitGroup>,
}

/// Format groups as TOML for editor editing.
fn format_groups_for_editor(groups: &[CommitGroup]) -> String {
    let header = "# Atomic Commit Groups\n\
                  # Edit messages, move files between groups, or delete groups.\n\
                  # Empty groups (no files) will be skipped.\n\n";

    let wrapper = EditorGroups {
        groups: groups.to_vec(),
    };
    let toml_body = toml::to_string_pretty(&wrapper).unwrap_or_default();

    // Insert "# Group N" comments before each [[groups]] for readability
    let mut count = 0usize;
    let toml_body = toml_body
        .lines()
        .map(|line| {
            if line.trim() == "[[groups]]" {
                count += 1;
                format!("# Group {}\n{}", count, line)
            } else {
                line.to_string()
            }
        })
        .collect::<Vec<_>>()
        .join("\n");

    format!("{}{}\n", header, toml_body)
}

/// Parse groups from TOML editor output.
fn parse_groups_from_editor(text: &str, expected_files: &[String]) -> Result<Vec<CommitGroup>> {
    let editor_groups: EditorGroups = toml::from_str(text)
        .map_err(|e| GcopError::SplitParseFailed(format!("TOML parse error: {}", e)))?;

    // Filter out empty groups (no files or empty message)
    let groups: Vec<CommitGroup> = editor_groups
        .groups
        .into_iter()
        .filter(|g| !g.files.is_empty() && !g.message.trim().is_empty())
        .map(|mut g| {
            // Trim trailing whitespace from message
            g.message = g.message.trim().to_string();
            g
        })
        .collect();

    if groups.is_empty() {
        return Err(GcopError::SplitParseFailed(
            "No valid groups found in editor output".to_string(),
        ));
    }

    // Validate: no duplicate files
    let mut seen = std::collections::HashSet::new();
    for group in &groups {
        for file in &group.files {
            if !seen.insert(file.clone()) {
                return Err(GcopError::SplitParseFailed(format!(
                    "File '{}' appears in multiple groups",
                    file
                )));
            }
        }
    }

    // Warn about missing files
    let expected_set: std::collections::HashSet<_> = expected_files.iter().cloned().collect();
    let missing: Vec<_> = expected_set.difference(&seen).collect();
    if !missing.is_empty() {
        tracing::warn!("Files removed from groups: {:?}", missing);
    }

    Ok(groups)
}

/// Open groups in editor for editing.
fn edit_groups_in_editor(
    groups: &[CommitGroup],
    expected_files: &[String],
) -> Result<Option<Vec<CommitGroup>>> {
    let content = format_groups_for_editor(groups);

    match ui::edit_text(&content) {
        Ok(edited) => {
            let parsed = parse_groups_from_editor(&edited, expected_files)?;
            Ok(Some(parsed))
        }
        Err(GcopError::UserCancelled) => Ok(None),
        Err(e) => Err(e),
    }
}

// --- JSON mode ---------------------------------------------------------------

/// Handle `--split --json` mode.
async fn handle_split_json_mode(
    options: &CommitOptions<'_>,
    config: &AppConfig,
    repo: &dyn GitOperations,
    provider: &Arc<dyn LLMProvider>,
    initial_feedbacks: &[String],
) -> Result<()> {
    if !repo.has_staged_changes()? {
        json::output_json_error::<SplitCommitData>(&GcopError::NoStagedChanges)?;
        return Err(GcopError::NoStagedChanges);
    }

    let diff = repo.get_staged_diff()?;
    let stats = repo.get_diff_stats(&diff)?;
    let file_diffs = split_diff_by_file(&diff);
    let branch_name = repo.get_current_branch()?;
    let custom_prompt = config.commit.custom_prompt.clone();
    let scope_info = super::commit::compute_scope_info_pub(&stats.files_changed, config);

    match generate_groups(
        provider,
        &file_diffs,
        &stats,
        config,
        initial_feedbacks,
        options.verbose,
        &branch_name,
        &custom_prompt,
        &scope_info,
        false,
        0,
    )
    .await
    {
        Ok(groups) => {
            let output = JsonOutput {
                success: true,
                data: Some(SplitCommitData {
                    groups,
                    diff_stats: (&stats).into(),
                    committed: false,
                }),
                error: None,
            };
            println!("{}", serde_json::to_string_pretty(&output)?);
            Ok(())
        }
        Err(e) => {
            json::output_json_error::<SplitCommitData>(&e)?;
            Err(e)
        }
    }
}

// --- Tests -------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_strip_code_fences_json() {
        let input = "```json\n{\"groups\": []}\n```";
        assert_eq!(strip_code_fences(input), "{\"groups\": []}");
    }

    #[test]
    fn test_strip_code_fences_plain() {
        let input = "```\n{\"groups\": []}\n```";
        assert_eq!(strip_code_fences(input), "{\"groups\": []}");
    }

    #[test]
    fn test_strip_code_fences_none() {
        let input = "{\"groups\": []}";
        assert_eq!(strip_code_fences(input), "{\"groups\": []}");
    }

    #[test]
    fn test_parse_split_response_valid() {
        let raw = r#"{"groups": [{"files": ["a.rs", "b.rs"], "message": "feat: add stuff"}]}"#;
        let expected = vec!["a.rs".to_string(), "b.rs".to_string()];
        let groups = parse_split_response(raw, &expected).unwrap();
        assert_eq!(groups.len(), 1);
        assert_eq!(groups[0].files, vec!["a.rs", "b.rs"]);
        assert_eq!(groups[0].message, "feat: add stuff");
    }

    #[test]
    fn test_parse_split_response_with_fences() {
        let raw =
            "```json\n{\"groups\": [{\"files\": [\"a.rs\"], \"message\": \"fix: bug\"}]}\n```";
        let expected = vec!["a.rs".to_string()];
        let groups = parse_split_response(raw, &expected).unwrap();
        assert_eq!(groups.len(), 1);
    }

    #[test]
    fn test_parse_split_response_empty_groups() {
        let raw = r#"{"groups": []}"#;
        let result = parse_split_response(raw, &[]);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_split_response_duplicate_file() {
        let raw = r#"{"groups": [
            {"files": ["a.rs"], "message": "feat: one"},
            {"files": ["a.rs"], "message": "feat: two"}
        ]}"#;
        let expected = vec!["a.rs".to_string()];
        let result = parse_split_response(raw, &expected);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("multiple groups"));
    }

    #[test]
    fn test_parse_split_response_empty_message() {
        let raw = r#"{"groups": [{"files": ["a.rs"], "message": ""}]}"#;
        let expected = vec!["a.rs".to_string()];
        let result = parse_split_response(raw, &expected);
        assert!(result.is_err());
    }

    #[test]
    fn test_format_and_parse_editor_roundtrip() {
        let groups = vec![
            CommitGroup {
                files: vec!["src/main.rs".to_string(), "src/lib.rs".to_string()],
                message: "feat: add new feature".to_string(),
            },
            CommitGroup {
                files: vec!["tests/test.rs".to_string()],
                message: "test: add tests".to_string(),
            },
        ];

        let editor_text = format_groups_for_editor(&groups);
        let expected_files = vec![
            "src/main.rs".to_string(),
            "src/lib.rs".to_string(),
            "tests/test.rs".to_string(),
        ];
        let parsed = parse_groups_from_editor(&editor_text, &expected_files).unwrap();

        assert_eq!(parsed.len(), 2);
        assert_eq!(parsed[0].message, "feat: add new feature");
        assert_eq!(parsed[0].files, vec!["src/main.rs", "src/lib.rs"]);
        assert_eq!(parsed[1].message, "test: add tests");
        assert_eq!(parsed[1].files, vec!["tests/test.rs"]);
    }

    #[test]
    fn test_format_and_parse_editor_multiline_message() {
        let groups = vec![CommitGroup {
            files: vec!["src/auth.rs".to_string()],
            message: "feat(auth): add login\n\nDetailed description.\n- bullet point".to_string(),
        }];

        let editor_text = format_groups_for_editor(&groups);
        assert!(editor_text.contains("\"\"\""));

        let expected_files = vec!["src/auth.rs".to_string()];
        let parsed = parse_groups_from_editor(&editor_text, &expected_files).unwrap();

        assert_eq!(parsed.len(), 1);
        assert_eq!(
            parsed[0].message,
            "feat(auth): add login\n\nDetailed description.\n- bullet point"
        );
    }

    #[test]
    fn test_parse_split_response_extra_files_rejected() {
        // LLM returns a file that was never staged — must be a hard error
        let raw = r#"{"groups": [
            {"files": ["a.rs", "unstaged.rs"], "message": "feat: one"}
        ]}"#;
        let expected = vec!["a.rs".to_string()];
        let result = parse_split_response(raw, &expected);
        assert!(result.is_err());
        let msg = result.unwrap_err().to_string();
        assert!(
            msg.contains("not in staging area"),
            "error should mention staging area, got: {msg}"
        );
    }

    #[test]
    fn test_parse_split_response_extra_files_across_groups_rejected() {
        // Extra file spread across multiple groups — still rejected
        let raw = r#"{"groups": [
            {"files": ["a.rs"], "message": "feat: one"},
            {"files": ["b.rs", "surprise.rs"], "message": "feat: two"}
        ]}"#;
        let expected = vec!["a.rs".to_string(), "b.rs".to_string()];
        let result = parse_split_response(raw, &expected);
        assert!(result.is_err());
        assert!(
            result
                .unwrap_err()
                .to_string()
                .contains("not in staging area")
        );
    }

    #[test]
    fn test_parse_split_response_no_extra_files_ok() {
        // Exact match — should pass
        let raw = r#"{"groups": [
            {"files": ["a.rs"], "message": "feat: one"},
            {"files": ["b.rs"], "message": "feat: two"}
        ]}"#;
        let expected = vec!["a.rs".to_string(), "b.rs".to_string()];
        assert!(parse_split_response(raw, &expected).is_ok());
    }
}
